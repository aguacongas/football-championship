type Environment @model
{
	id: ID!
	results: [GlobalResult!]! @connection(name: "EnvironmentResults", sortField: "value")
}

type Competition 
  @model 
  @auth(rules: [
      {allow: groups, groups: ["Admin"], queries: [get, list], mutations: [create, update, delete]},
      {allow: groups, groups: ["User"], queries: [get, list], mutations: null}
    ])
{
  id: ID!
  title: String!
  localizedNames: [LocalizedName!]
  from: AWSDate!
  to: AWSDate!
  matches: [Match!]! @connection(name: "CompetitionMatches", sortField: "beginAt")
  bets: [Bet!]! @connection(name: "CompetitionBets")
  results: [Result!]! @connection(name: "CompetitionResults", sortField: "value")
}

type Match
  @model
  @auth(rules: [
      {allow: groups, groups: ["Admin"], queries: [get, list], mutations: [create, update, delete]},
      {allow: groups, groups: ["User"], queries: [get, list], mutations: null}
    ])
{
  id: ID!
  competition: Competition! @connection(name: "CompetitionMatches")
  group: [LocalizedName!]
  number: Int
  beginAt: AWSDateTime!
  placeHolderHome: String!
  placeHolderAway: String!
  localizedNames: [LocalizedName!]
  matchTeams: [MatchTeam!]! @connection(name: "MatchTeamMatchs")
  bets: [Bet!]! @connection(name: "MatchBets")
  scores: [Score!]
}

type Team
  @model
  @auth(rules: [
      {allow: groups, groups: ["Admin"], queries: [get, list], mutations: [create, update, delete]},
      {allow: groups, groups: ["User"], queries: [get, list], mutations: null}
    ])
{
  id: ID!
  name: String!
  localizedNames: [LocalizedName!]
  flagUrl: String
  matchTeams: [MatchTeam!]! @connection(name: "MatchTeamTeams")
}

type MatchTeam
  @model
  @auth(rules: [
      {allow: groups, groups: ["Admin"], queries: [get, list], mutations: [create, update, delete]},
      {allow: groups, groups: ["User"], queries: [get, list], mutations: null}
    ])
{
  id: ID!
  isHome: Boolean!
  team: Team! @connection(name: "MatchTeamTeams")
  match: Match! @connection(name: "MatchTeamMatchs")
}

type Bet
  @model
  @auth(rules: [
      {allow: owner},
      {allow: groups, groups: ["User"], queries: [get, list], mutations: null}
    ])
{
  id: ID!
  owner: String!
  userName: String!
  match: Match! @connection(name: "MatchBets")
  competition: Competition! @connection(name: "CompetitionBets")
  scores: [Score!]!
}

type Result
  @model
  @auth(rules: [
	  {allow: owner},
      {allow: groups, groups: ["User"], queries: [get, list], mutations: null}
    ])
 {
   id: ID!
   owner: String!
   userName: String!
   value: Int!
   competition: Competition! @connection(name: "CompetitionResults")
 }

 type GlobalResult
  @model
  @auth(rules: [
	  {allow: owner},
      {allow: groups, groups: ["User"], queries: [get, list], mutations: null}
    ])
 {
   id: ID!
   owner: String!
   userName: String!
   value: Int!
   environment: Environment! @connection(name: "EnvironmentResults")
 }

type Score {
  isHome: Boolean!
  value: Int!
}

type LocalizedName {
  locale: String!
  value: String!
}

input ModelMatchFilterInput {
	id: ModelIDFilterInput
	beginAt: ModelStringFilterInput
	placeHolderHome: ModelStringFilterInput
	placeHolderAway: ModelStringFilterInput
    matchCompetitionId: ModelIDFilterInput
	and: [ModelMatchFilterInput]
	or: [ModelMatchFilterInput]
	not: ModelMatchFilterInput
}

input ModelBetFilterInput {
	id: ModelIDFilterInput
	owner: ModelStringFilterInput
	userName: ModelStringFilterInput
	betCompetitionId: ModelIDFilterInput
	betMatchId: ModelIDFilterInput
	and: [ModelBetFilterInput]
	or: [ModelBetFilterInput]
	not: ModelBetFilterInput
}

input ModelResultFilterInput {
	id: ModelIDFilterInput
	owner: ModelStringFilterInput
	userName: ModelStringFilterInput
	value: ModelIntFilterInput
	resultCompetitionId: ModelIDFilterInput
	and: [ModelResultFilterInput]
	or: [ModelResultFilterInput]
	not: ModelResultFilterInput
}

input ModelIDFilterInput {
	ne: ID
	eq: ID
	le: ID
	lt: ID
	ge: ID
	gt: ID
	contains: ID
	notContains: ID
	between: [ID]
	beginsWith: ID
}

input ModelStringFilterInput {
	ne: String
	eq: String
	le: String
	lt: String
	ge: String
	gt: String
	contains: String
	notContains: String
	between: [String]
	beginsWith: String
}

input ModelIntFilterInput {
	ne: Int
	eq: Int
	le: Int
	lt: Int
	ge: Int
	gt: Int
	contains: Int
	notContains: Int
	between: [Int]
}
